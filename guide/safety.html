<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Safety - GPU Computing with Rust using CUDA</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="Writing extremely fast GPU Computing code with rust using rustc_codegen_nvvm and CUDA">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../features.html"><strong aria-hidden="true">2.</strong> Supported Features</a></li><li class="chapter-item expanded "><a href="../faq.html"><strong aria-hidden="true">3.</strong> Frequently Asked Questions</a></li><li class="chapter-item expanded "><a href="../guide/index.html"><strong aria-hidden="true">4.</strong> Guide</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../guide/getting_started.html"><strong aria-hidden="true">4.1.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="../guide/tips.html"><strong aria-hidden="true">4.2.</strong> Tips</a></li><li class="chapter-item expanded "><a href="../guide/kernel_abi.html"><strong aria-hidden="true">4.3.</strong> Kernel ABI</a></li><li class="chapter-item expanded "><a href="../guide/safety.html" class="active"><strong aria-hidden="true">4.4.</strong> Safety</a></li></ol></li><li class="chapter-item expanded "><a href="../cuda/index.html"><strong aria-hidden="true">5.</strong> The CUDA Toolkit</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../cuda/gpu_computing.html"><strong aria-hidden="true">5.1.</strong> GPU Computing</a></li><li class="chapter-item expanded "><a href="../cuda/pipeline.html"><strong aria-hidden="true">5.2.</strong> The CUDA Pipeline</a></li></ol></li><li class="chapter-item expanded "><a href="../nvvm/index.html"><strong aria-hidden="true">6.</strong> rustc_codegen_nvvm</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../nvvm/technical/index.html"><strong aria-hidden="true">6.1.</strong> Technical</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../nvvm/technical/backends.html"><strong aria-hidden="true">6.1.1.</strong> Custom Rustc Backends</a></li><li class="chapter-item expanded "><a href="../nvvm/technical/nvvm.html"><strong aria-hidden="true">6.1.2.</strong> rustc_codegen_nvvm</a></li><li class="chapter-item expanded "><a href="../nvvm/technical/types.html"><strong aria-hidden="true">6.1.3.</strong> Types</a></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">GPU Computing with Rust using CUDA</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="safety"><a class="header" href="#safety">Safety</a></h1>
<p>With one of Rust's main foci being memory safety, we strive to make most things
safe, without requiring too much unsafe usage and mental checks from the user. However,
CUDA's inherent thread/memory model leaves many things ambiguous as to whether they are sound
and makes many invariants inherently impossible to statically prove. In this section
we will talk about what kinds of behavior is considered undefined inside of kernels as
well as the invariants that must be upheld by the caller of kernels.</p>
<p>⚠️ This list is not fully complete, as the semantics of Rust safety on the GPU have not been explored much,
however, this list includes most of the actions "regular" users may commit ⚠️</p>
<h2 id="behavior-considered-undefined-in-gpu-kernels"><a class="header" href="#behavior-considered-undefined-in-gpu-kernels">Behavior considered undefined in GPU kernels</a></h2>
<p>This list is purely meant to be a guide on what behavior should be avoided.</p>
<p>Undefined behavior on the GPU is defined as potentially being able to cause the following (but not limited to):</p>
<ul>
<li>Unknown/Undefined data being written to a location in memory.</li>
<li>Causing fatal termination of either just the kernel (through trapping), or the entire CUDA driver (through invalid address errors).</li>
<li>Causing LLVM/NVVM to optimize the code into unknown code.</li>
</ul>
<p>Behavior considered undefined inside of GPU kernels:</p>
<ul>
<li>Most importantly, any behavior that is considered undefined on the CPU, is considered undefined
on the GPU too. See: https://doc.rust-lang.org/reference/behavior-considered-undefined.html.
The only exception being invalid sizes for buffers given to a GPU kernel.</li>
</ul>
<p>Currently we declare that the invariant that a buffer given to a gpu kernel must be large enough for any access the
kernel is going to make is up to the caller of the kernel to uphold. This idiom may be changed in the future.</p>
<ul>
<li>Any kind of data race, this has the same semantics as data races in CPU code. Such as:
<ul>
<li>Multiple threads writing to a location in memory at the same time without synchronization.</li>
<li>One or more threads reading while a thread is writing to a memory location.</li>
<li>Reading shared memory while a thread is writing to the location (if for example <code>thread::sync</code> has not been called).</li>
</ul>
</li>
</ul>
<p>Behavior not currently considered undefined, but considered undesirable:</p>
<ul>
<li>calling <code>thread::sync</code> inside of a branch that not all threads inside of the thread block have reached.</li>
</ul>
<h2 id="behavior-considered-undefined-on-the-cpu"><a class="header" href="#behavior-considered-undefined-on-the-cpu">Behavior considered undefined on the CPU</a></h2>
<p>This list will contain behavior that is considered undefined in the context of actually launching GPU kernels from
the CPU.</p>
<h3 id="streams"><a class="header" href="#streams">Streams</a></h3>
<p>Streams will always execute concurrently with eachother. That is to say, kernels launched
inside of a single stream guarantee that they will be executed one after the other, in order.</p>
<p>However, kernels launched in different streams have no guarantee of execution order, their execution
may be interleaved and kernels are likely to be launched concurrently on the GPU.</p>
<p><img src="../../assets/streams.svg" alt="" /></p>
<p>Therefore, it is undefined behavior to write to the same memory location in kernels executed in different
streams without synchronization.</p>
<p>For example:
1: <code>Foo</code> is allocated as a buffer of memory on the GPU.
2: Stream <code>1</code> launches kernel <code>bar</code> which writes to <code>Foo</code>.
3: Stream <code>2</code> launches kernel <code>bar</code> which also writes to <code>Foo</code>.</p>
<p>This is undefined behavior because the kernels are likely to be executed concurrently, causing a data
race when multiple kernels try to write to the same memory.</p>
<p>However, if the thread that Stream <code>2</code> is located on calls <code>synchronize()</code> on Stream <code>1</code> before launching the kernel,
this will be sound. Because <code>synchronize()</code> waits for Stream <code>2</code> to finish all of its tasks before giving back control
to the calling thread.</p>
<p>Another important detail is that GPU operations on a stream are NOT synchronized with the CPU.
This means that CPU code may not rely on a kernel being finished without calling <code>synchronize()</code>. For example:</p>
<pre><code class="language-rs">launch!(module.bar&lt;&lt;&lt;1, 1, 0, stream&gt;&gt;&gt;(foo.as_unified_ptr()))?;
// 'bar' is not guaranteed to be finished executing at this point.
function_that_accesses_foo(foo);
stream.synchronize()?;
// foo may be accessed and will see the changes that 'bar' wrote to 'foo'. 'bar' is guaranteed 
// to be finished executing.
</code></pre>
<h3 id="contexts"><a class="header" href="#contexts">Contexts</a></h3>
<p>Contexts are akin to CPU processes, therefore, it is undefined behavior (although it should always yield an invalid address error) to
access another context's allocated GPU memory.</p>
<p>However, this is very uncommon because single-device code should not need multiple contexts generally. This only becomes relevant
when using multiple devices (multi-GPU code) with different contexts.</p>
<p>Note however, that unified memory can be accessed by multiple GPUs and multiple contexts at the same time, as unified memory
takes care of copying and moving data automatically from GPUs/CPU when a page fault occurs. For this reason
as well as general ease of use, we suggest that unified memory generally be used over regular device memory.</p>
<h3 id="kernel-launches"><a class="header" href="#kernel-launches">Kernel Launches</a></h3>
<p>Kernel Launches are the most unsafe part of CUDA, many things must be checked by the developer to soundly launch a kernel.
It is fundamentally impossible for us to verify a large portion of the invariants expected by the kernel/CUDA.</p>
<p>The following invariants must be upheld by the caller of a kernel, failure to do so is undefined behavior:</p>
<ul>
<li>The number of parameters passed to the kernel must match the expected number of parameters.</li>
<li>The dimensionality expected by the kernel must match, e.g. if the kernel expects 2d thread indices, it is undefined
behavior to launch the kernel with 3d thread indices (which would cause a data race). However, it is not undefined behavior
to launch the kernel with a dimensionality lower than expected, e.g. launching a 2d kernel with a 1d dimensionality.</li>
<li>The types expected by the kernel must match:
<ul>
<li>If the kernel expects a struct, if the struct is repr(Rust), the struct must be the actual struct from the kernel library,
otherwise, if it is repr(C) (which is reccomended), the fields must all match, including alignment and order of fields.</li>
</ul>
</li>
<li>Reference aliasing rules must not be violated, including:
<ul>
<li>Immutable references are allowed to be aliased, e.g. if a kernel expects <code>&amp;T</code> and <code>&amp;T</code>, it is sound to pass the same pointer for both.</li>
<li>Data behind an immutable reference must not be modified, meaning, it is undefined behavior to pass the same pointer to <code>&amp;T</code> and <code>*mut T</code>,
where <code>*mut T</code> is used for modifying the data.</li>
<li>Parameters such as <code>&amp;[UnsafeCell&lt;T&gt;]</code> must be exclusive, assuming the kernel uses the <code>UnsafeCell&lt;T&gt;</code> to modify the data.</li>
<li><code>*mut T</code> does not necessarily need to follow aliasing rules, it is sound to pass the same pointer to two <code>*mut T</code> parameters
assuming that the kernel accesses nonoverlapping regions of the memory. If a mutable reference is formed from
the pointer, the mutable reference <strong>must</strong> be exclusive, e.g. it is undefined behavior for two threads to create a mutable
reference to the same element in a pointer.</li>
</ul>
</li>
<li>Any buffers passed to the kernel must be large enough for the size that the kernel expects. Allocated buffer size being correct
for what the kernel expects is up to the caller, not the kernel.</li>
<li>Not allocating enough dynamic shared memory for how much the kernel expects.</li>
</ul>
<p>Behavior that is not considered undefined but is undesirable:</p>
<ul>
<li>Launching a kernel with more threads than expected by its launch bounds (.maxntid in PTX). This will cause the launch to fail.</li>
<li>Launching a kernel with a different number of threads than expected by its launch bounds (.reqntid in PTX). This will also cause the launch to fail.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../guide/kernel_abi.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../cuda/index.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../guide/kernel_abi.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../cuda/index.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
